# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Горин Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Списки - важная структура данных языка Пролог, которая позволяет выполнять множество манипуляций и вычислений с данными. Список состоит из двух элементов - головы и хвоста. Отделение головы и дальнейшая рекурсивная работа с хвостом является наиболее частой практикой работы с ними. По своей сути списки в Пролог похожи на массивы, векторы и связные списки, но принципиально отличаются реализацией. Гораздо точнее будет сравнить списки в Пролог с бинарными деревьями, где левым потомком корневого узла является голова, а правым потомком хвост, и затем для хвоста выполняется то же правило (последним правым узлом является пустой список). Это не мешает определить для них стандартные операции (доступ к элементу через индекс, добавление/удаление частей и т.д.). Однако стоит учесть, что работать они все будут за O(len(list)). Также важной особенностью является произвольный тип элементов списка и отсутствие фиксированного размера, что не характерно для большинства императивных языков (строго типизированныых). 

## Задание 1.1: Предикат обработки списка

`myremove_n_stand(N, List, Result)` - Удаление N последних элементов из списка
N - число элементов, требуемых для удаления, List - текущий список, Result - результирующий список.
`myremove_n_nostand(N, List, Result)` - Версия без использования стандартных предикатов.

Примеры использования:
```prolog
1 ?- myremove_n_stand(4,[1,2,3,4],X).
X = [] .

2 ?- myremove_n_stand(2,[1,2,3,4],X). 
X = [1, 2] .

3 ?- myremove_n_stand(0,[1,2,3,4],X). 
X = [1, 2, 3, 4] .

4 ?- myremove_n_nostand(4,[1,2,3,4],X).
X = [] .

5 ?- myremove_n_nostand(2,[1,2,3,4],X). 
X = [1, 2] .

6 ?- myremove_n_nostand(0,[1,2,3,4],X). 
X = [1, 2, 3, 4] .
```

Реализация с использованием стандартных предикатов:
```prolog
myremove_n_stand(0, List, List).
myremove_n_stand(N, List, Result) :- 
  N > 0, length(Deleted, N), 
  append(Result, Deleted, List).
```
Здесь используется нахождение длины списка и конкатенация списков. Смысл состоит в том, что требуется найти удаленный список такой длины, чтобы при добавлении к результату получался исходный список. Таким образом находится разбиение списка на Result и Deleted части, остается лишь вернуть первую.

Реализация без использования стандартных предикатов:
```prolog
myremove_n_nostand(0, X, X).

myremove_n_nostand(1, [_], []).
myremove_n_nostand(1, [X|Xs], [X|Result]) :-
  myremove_n_nostand(1, Xs, Result).

myremove_n_nostand(N, Input, L) :- 
  N > 1,
  N1 is N - 1,
  myremove_n_nostand(1, Input, Res),
  myremove_n_nostand(N1, Res, L).
```

Правило при N = 0 очевидно, при N = 1 запускается рекурсия до того момента, пока в списке не будет лишь один элемент, он и отсечется и не запишется в результат.
Распространить работу предиката на все натуральные числа несложно - достаточно лишь получить список с отсеченным последним элементом (Res) и затем повторить рекурсию для N-1 и записать результат в L.

## Задание 1.2: Предикат обработки числового списка

`index_of_max_stand(L, Index)` - Вычисление позиции максимального элемента в списке
L - исходный список, Index - полученная позиция первого вхождения максимального элемента.

`index_of_max_nostand(L,Index)` - Версия без использования стандартных предикатов.

Примеры использования:
```prolog
7 ?- index_of_max_stand([1,2,3,4,5],X). 
X = 4.

8 ?- index_of_max_stand([1],X).         
X = 0.

9 ?- index_of_max_stand([1,2,2,4,2,4,1],X). 
X = 3.

10 ?- index_of_max_nostand([1,2,3,4,5],X). 
X = 4 .

11 ?- index_of_max_nostand([1],X). 
X = 0 .

12 ?- index_of_max_nostand([1,2,2,4,2,4,1],X). 
X = 3 .

13 ?- index_of_max_stand([],X).              
false.

14 ?- index_of_max_nostand([],X).              
false.
```

Реализация с использованием стандартных предикатов:
```prolog
index_of_max_stand(L, Index):-
  max_list(L, El), 
  nth0(Index, L, El), !.
```
Простейшая логика. max_list получает максимальный элемент El, а затем ведется поиск первого вхождения этого элемента в список с помощью nth0.

Реализация без использования стандартных предикатов:
```prolog
%-----------------------------------------
index_of_max_nostand(L,Index):-
  get_max(L,Max),
  index_of(L,0,Index,Max). 
%-----------------------------------------
compare_max(X,Y,Z) :- atomic(X), atomic(Y), (X >= Y, Z is X); (X < Y, Z is Y).
%-----------------------------------------
get_max([H|T], Max) :-
  get_max(T, H, Max).

get_max([], Max, Max).
get_max([H|T], MaxLast, Max):-
    compare_max(H, MaxLast, MaxTemp),
    get_max(T, MaxTemp, Max).
%-----------------------------------------
index_of([Max|_], I, I, Max).
index_of([_|T], CurInd, IndMax, Max):-
    NewInd is CurInd + 1,
    index_of(T, NewInd, IndMax, Max).
%-----------------------------------------
```
Аналогичные рассуждения, но требуется ручная реализация получения максимального элемента и поиска его индекса. Эти вещи выполняют предикаты get_max(List, Max) и index_of(List, BeginInd, IndMax, Max). 

Первый предикат получает на вхождение список List и осуществляет поиск максимума с помощью его запоминания и рекурсивного разделения списка на голову и хвост (с последующим сравнением максимума с головой)

Второй предикат получает на вход список List, BeginInd - индекс, с которого начинается поиск (в общем случае с 0), а также найденный максимум Max и ищет третий аргумент - индекс максимума. Рекурсия с хранением текущего индекса и при равенстве головы с максимумом выполняется `index_of([Max|_], I, I, Max).`, где позиция перезаписывается и рекурсия заканчивается. 

## Задание 2: Реляционное представление данных

Главными преимуществами реляционного представления данных является структуированность и организация. С помощью столбцов, строк, однотипных записей удобно хранить большой объем данных в соответствии с выбранным стандартом. Они легко масштабируемы, то есть зная структуру, можно легко добавлять новые записи. Они также обладают некоторой гибкостью в том смысле, что всегда можно добавить новую таблицу с совершенно новыми данными и хранить связь со старой таблицей (в нашем случае можно добавить, например, даты рождения каждого студента и поддерживать связность с помощью имени и фамилии самого студента - оно должно совпасть в новой и старой таблице).
Также большим плюсом является удобство манипуляций с данными и запросы к ним - благодаря этому появился целый язык структуированных запросов к реляционным базам данных - SQL. 

Однако не обошлось и без минусов. Ручное чтение таких данных затруднительно вследствие возможного неестественного их представления в исходном виде, а порой почти невозможно. Если в файле `two.pl` еще возможно без труда читать данные без помощи программы, то работать с `three.pl` таким образом почти невозможно. Структуированность каждой записи накладывает свои ограничения `А если я захочу в группу к студентам добавить школьника?` - нужно придумывать либо новую таблицу, либо заменить студента на человека и добавить свойство студент/школьник. Оба варианта затратны. Также необходимо поддерживать целостность данных - мелкая ошибка в любой записи приводит в лучшем случае к неправильному ответу, в худшем - к невозможности прочтения всех данных.

`average_mark(Subject, Result)` - Вычисление среднего балла для каждого предмета

Примеры использования:
```prolog
1 ?- average_mark('Информатика', X).
X = 3.9285714285714284.

2 ?- average_mark('Математический анализ', X). 
X = 3.892857142857143.
```

Реализация:
```prolog
average_mark(Subject, Result):-
    findall(M, grade(_, _, Subject, M), AllMarks),
    sum_list(AllMarks, Sum),
    length(AllMarks, Len),
    Result is Sum / Len.
```

С помощью findall создается список AllMarks, куда попадает каждая оценка, подходящая под условие (заданный предмет). Затем находится сумма всех элементов списка и делится на их количество. sum_list легко пишется вручную.

`failed_students_group(Group, Result)` - Количество Result не сдавших студентов для группы Group. 

Примеры использования:
```prolog
3 ?- failed_students_group(102,X).
X = 5.

4 ?- failed_students_group(104,X). 
X = 2.
```

Реализация:
```prolog
failed_students_group(Group, Result):-
    findall(St, grade(Group, St, _, 2), L),
    length(L, Result).
```
Аналогично все в список L попадают все записи grade, где оценка равна 2 и совпадает группа. Затем выводится длина этого списка.

`failed_students_subject(Subject, Result)` - Подсчет количества студентов, не сдавших определенный предмет Subject

Примеры использования:
```prolog
6 ?- failed_students_subject('Информатика',X). 
X = 2.

7 ?- failed_students_subject('Математический анализ',X). 
X = 3.
```

Реализация:
```prolog
failed_students_subject(Subject, Result):-
    findall(St, grade(_, St, Subject, 2), L),
    length(L, Result).
```
Аналогичные рассуждения, что и в предыдущем предикате, только вместо Group теперь поиск соответствия по Subject.

## Выводы

Встретил огромные трудности с пониманием не только самой сути Prolog, но и в принципе с декларативным подходом. Отсутствие полного контроля над управлением каждого шага программы зачастую сбивало с толку и приводило к многочисленным ошибкам. 

Затем я заметил, что некоторые задачи решаются в Prolog в разы быстрее, чем с помощью императивных языков программирования. Написание всех возможных перестановок, удовлетворяющих некоторым условиям, вывод всевозможных разложений чисел и выражений, работы с конечными множествами, а также различные рекурсивные алгоритмы пишутся на Prolog намного быстрее и проще - стоит лишь описать, каким условиям должно удовлетворять решение. Однако здесь кроется и недостаток - очень большие программы со сложной логикой на Prolog написать все же проблематично из-за трудностей отслеживания состояния программы и нелинейного выполнения кода. Также Prolog не обладает многими преимуществами функционального и объектного подхода к программированию, практичность у него низкая.

В ходе выполнения лабораторной работы я столкнулся с ограниченностью "инструментария" - сложно было мыслить лишь в рамках списков и переменных. Конечно, это приводило как к изящным и творческим решениям - например, удаление нужного числа элементов из списка с помощью всего лишь двух стандартных предикатов, так и к затруднениям и вынужденности переходить к императивному псевдокоду и переводу его на Prolog - как в ручной реализации вычисления позиции максимального элемента. 





